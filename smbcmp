#!/usr/bin/env python3
# Compare SMB packets from 2 network capture files
#
# Copyright (C) 2017 Aurelien Aptel <aurelien.aptel@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import subprocess
import re
import tempfile
import curses
import os
import functools
import difflib
import configparser
import binascii

TSHARK_FILTER_FLAG = None
DEFAULT_CONFIG = os.path.expanduser("~/.smbcmp")
KEY = {}
CONF = configparser.ConfigParser()
CRYPTO_KEY = {}

def load_config(fn):
    CONF.read(fn)
    def k(name, default):
        KEY[name] = CONF['global'].get('key_'+name, default)
    k('lwin_next', 'd')
    k('lwin_prev', 'f')
    k('rwin_next', 'j')
    k('rwin_prev', 'k')
    k('top_next', 'KEY_DOWN')
    k('top_prev', 'KEY_UP')
    k('bwin_next', 'b')
    k('bwin_prev', 'n')
    k('vsplit_up', 'KEY_PPAGE')
    k('vsplit_down', 'KEY_NPAGE')

def wireshark_checks(args):
    try:
        out = subprocess.check_output(tshark('-h')).decode('utf-8')
    except:
        print("Can't run tshark, check if installed properly")
        raise

    if 'wireshark' not in out:
        raise Exception("Unexpected tshark out, check if installed properly")

    global TSHARK_FILTER_FLAG
    if '-Y' in out:
        TSHARK_FILTER_FLAG = '-Y'
    else:
        TSHARK_FILTER_FLAG = '-R'

    if args.key:
        try:
            out = subprocess.check_output(tshark('-ouat:smb2_seskey_list:ffffffffffffffff'+
                                                 ',ffffffffffffffffffffffffffffffff',
                                                 '-v')).decode('utf-8')
        except:
            print("your version of tshark doesn't support decryption")
            raise

def strip_packet_no(arg):
    try:
        i = arg.rindex(":")
        return arg[:i]
    except Exception:
        return arg

def split_packet_arg(arg):
    try:
        m = re.match(r'^(.+):(\d+)$', arg)
        fn = m.group(1)
        no = int(m.group(2))
        return (fn, no)
    except Exception:
        raise Exception("invalid packet:no specified")

def extract_kernel_keys(log):
    r = {}
    last_id = None
    last_key = None
    rx = re.compile(r'''(?:Session Id\s+((?: [a-f0-9]{2})+))|(?:Session Key\s+((?: [a-f0-9]{2})+))''')
    for m in rx.finditer(log):
        if m.group(1):
            last_id = hex_to_bytes(m.group(1))
        elif m.group(2):
            last_key = hex_to_bytes(m.group(2))
            r[last_id] = last_key
            last_key = last_id = None
    return r

def load_crypto_keys(args):
    # try dmesg
    try:
        dmesg = subprocess.check_output(["dmesg"]).decode("utf-8")
        CRYPTO_KEY.update(extract_kernel_keys(dmesg))
    except Exception as e:
        pass

    for kp in args.key:
        m = re.match(r'''^([a-f0-9]+),([a-f0-9]+)$''', kp)
        if m:
            sid = hex_to_bytes(m.group(1))
            skey = hex_to_bytes(m.group(2))
            CRYPTO_KEY[sid] = skey
        elif os.path.exists(kp):
            CRYPTO_KEY.update(extract_kernel_keys(open(kp).read()))
        else:
            raise Exception("<%s> is neither a file nor a hex SID,KEY string"%kp)

def diff_split(w, h, vratio):
    lw = (w-1)//2
    rw = w-1-lw
    th = int((h-1)*vratio)
    bh = h-1-th
    return lw, rw, th, bh

def single_split(w, h, vratio):
    th = int((h-1)*vratio)
    bh = h-1-th
    return th, bh

def tshark(*args):
    binpath = CONF['global'].get('tshark_path', 'tshark')
    return [binpath] + list(args)

def bytes_to_hex(b):
    return binascii.hexlify(b).decode('ascii')

def hex_to_bytes(h):
    return binascii.unhexlify(h.replace(' ', ''))

def tshark_keys_opts():
    r = []
    for (sid, skey) in CRYPTO_KEY.items():
        opt = "-ouat:smb2_seskey_list:%s,%s"%(bytes_to_hex(sid), bytes_to_hex(skey))
        r.append(opt)
    return r


@functools.lru_cache(maxsize=128)
def smb_summaries(pcap):
    cmd = tshark(*tshark_keys_opts())
    cmd += ['-r', pcap, TSHARK_FILTER_FLAG, '!browser && (smb||smb2)']
    out = subprocess.check_output(cmd).decode('utf-8')
    pkts = {}
    for line in out.split('\n'):
        m = re.match(r'''\s*(\d+).+?SMB2?\s*\d+\s*(.+)''', line)
        if m:
            pkts[int(m.group(1))] = m.group(2)
    return pkts

@functools.lru_cache(maxsize=128)
def smb_packet(pcap, no):
    cmd = tshark(*tshark_keys_opts())
    cmd += ['-r', pcap, TSHARK_FILTER_FLAG, 'frame.number == %d'%no, '-V']
    out = subprocess.check_output(cmd).decode('utf-8')
    out = re.sub(r'^[\s\S]+\nSMB', 'SMB', out, re.S)
    return out

@functools.lru_cache(maxsize=128)
def smb_diff(a, b):
    lines = difflib.unified_diff(smb_packet(a[0], a[1]).split("\n"),
                                 smb_packet(b[0], b[1]).split("\n"),
                                 a[0], b[0], lineterm="")
    return "\n".join(lines)

class BufferViewer(object):
    def __init__(self, win, data, hl=True, diff=False, rxhl=None):
        self.win = win
        self.top = 0
        self.cursor = 0
        self.hl = hl
        self.diff = diff
        self.rxhl = None
        if rxhl:
            self.set_rxhl(rxhl)
        self.set_data(data)

    def set_data(self, data):
        self.data = data
        self.lines = self.data.split("\n")
        h = len(self.lines)-1
        self.top = max(0, min(h, self.top))
        self.cursor = max(0, max(self.top, min(h, self.cursor)))
        self.refresh()

    def set_rxhl(self, rxhl):
        self.rxhl = [(re.compile(rx), col) for rx,col in rxhl]

    def height(self):
        return self.win.getmaxyx()[0]

    def width(self):
        return self.win.getmaxyx()[1]

    def is_cursor_at_bot(self):
        return self.cursor - self.top == self.height()-1

    def is_cursor_at_top(self):
        return self.cursor == self.top

    def move(self, direction):
        if direction > 0 and self.cursor < len(self.lines)-1:
            if self.is_cursor_at_bot():
                self.top += 1
            self.cursor += 1
        elif direction < 0 and self.cursor > 0:
            if self.is_cursor_at_top():
                self.top -= 1
            self.cursor -= 1

    def refresh(self):
        self.win.erase()
        for nr, line in enumerate(self.lines[self.top:self.top+self.height()]):
            line = line.replace('\t', '    ')
            line = line[:self.width()-1]
            line = line.ljust(self.width()-1)
            attr = curses.A_NORMAL

            def write(s, a, x=0):
                if self.hl and self.cursor - self.top == nr:
                    a = a|curses.A_REVERSE
                self.win.addstr(nr, x, s, a)

            if self.diff:
                if line[0] == '-':
                    attr = attr|curses.color_pair(1)
                elif line[0] == '+':
                    attr = attr|curses.color_pair(2)

            write(line, attr)

            if not self.diff and self.rxhl:
                for rx,col in self.rxhl:
                    for m in rx.finditer(line):
                        write(m.group(1), col, x=m.start(1))

        self.win.noutrefresh()


class TraceViewer(object):
    def __init__(self, win, cap):
        self.buf = BufferViewer(win, '')
        self.buf.set_rxhl([
            (r'''(Error)''', curses.color_pair(1)|curses.A_BOLD),
        ])
        self.set_cap(cap)

    def set_cap(self, cap):
        self.cap = cap
        self.pkts = smb_summaries(cap)
        self.nos = sorted(self.pkts.keys())
        lines = []
        for no in self.nos:
            lines.append(self.pkts[no])
        self.buf.set_data('\n'.join(lines))

    def get_packet(self):
        return (self.cap, self.nos[self.buf.cursor])

    def move(self, direction):
        self.buf.move(direction)

    def refresh(self):
        self.buf.refresh()

def curses_init():
    curses.initscr
    curses.curs_set(0)
    curses.use_default_colors()
    curses.init_pair(1, curses.COLOR_RED, -1)
    curses.init_pair(2, curses.COLOR_GREEN, -1)

def single_view_main(stdscr, args):
    curses_init()

    H = curses.LINES
    W = curses.COLS
    th_ratio = CONF['global'].getfloat('vsplit_ratio', .5)
    th, bh = single_split(W, H, th_ratio)

    twin = curses.newwin(th, W, 0, 0)
    tbuf = TraceViewer(twin, strip_packet_no(args.filea))

    bwin = curses.newwin(bh, W, th+1, 0)
    bbuf = BufferViewer(bwin, "")
    resize = False
    bbuf.set_data(smb_packet(*tbuf.get_packet()))

    while True:
        stdscr.refresh()
        tbuf.refresh()
        bbuf.refresh()

        # y, x, ch, length
        stdscr.hline(th, 0, 0, W)

        last_packet = tbuf.get_packet()[1]

        k = stdscr.getkey()
        if k == 'q':
            return

        elif k in (KEY['lwin_next'], KEY['rwin_next'], KEY['top_next']):
            tbuf.move(+1)
        elif k in (KEY['lwin_prev'], KEY['rwin_prev'], KEY['top_prev']):
            tbuf.move(-1)

        elif k == KEY['bwin_next']:
            bbuf.move(+1)
        elif k == KEY['bwin_prev']:
            bbuf.move(-1)

        elif k == KEY['vsplit_up']:
            th_ratio += -.1
            resize = True
        elif k == KEY['vsplit_down']:
            th_ratio += +.1
            resize = True

        elif k == 'KEY_RESIZE':
            resize = True

        if resize:
            H, W = stdscr.getmaxyx()
            th, bh = single_split(W, H, th_ratio)
            twin.resize(th, W)
            bwin.resize(bh, W)
            bwin.mvwin(th+1, 0)
            resize = False

        if tbuf.get_packet()[1] != last_packet:
            bbuf.set_data(smb_packet(*tbuf.get_packet()))

def diff_view_main(stdscr, args):
    curses_init()

    H = curses.LINES
    W = curses.COLS
    th_ratio = CONF['global'].getfloat('vsplit_ratio', .5)
    lw, rw, th, bh = diff_split(W, H, th_ratio)

    # h, w, y, x
    lwin = curses.newwin(th, lw, 0, 0)
    lbuf = TraceViewer(lwin, strip_packet_no(args.filea))

    rwin = curses.newwin(th, rw, 0, lw+1)
    rbuf = TraceViewer(rwin, strip_packet_no(args.fileb))

    bwin = curses.newwin(bh, W, th+1, 0)
    bbuf = BufferViewer(bwin, "", diff=True)
    resize = False
    bbuf.set_data(smb_diff(lbuf.get_packet(), rbuf.get_packet()))

    while True:
        stdscr.refresh()
        rbuf.refresh()
        lbuf.refresh()
        bbuf.refresh()
        # y, x, ch, length
        stdscr.vline(0, lw, 0, th)
        stdscr.hline(th, 0, 0, W)

        last_lpacket = lbuf.get_packet()[1]
        last_rpacket = rbuf.get_packet()[1]

        k = stdscr.getkey()
        if k == 'q':
            return

        elif k == KEY['rwin_next']:
            rbuf.move(+1)
        elif k == KEY['rwin_prev']:
            rbuf.move(-1)

        elif k == KEY['lwin_next']:
            lbuf.move(+1)
        elif k == KEY['lwin_prev']:
            lbuf.move(-1)

        elif k == KEY['bwin_next']:
            bbuf.move(+1)
        elif k == KEY['bwin_prev']:
            bbuf.move(-1)

        elif k == KEY['vsplit_up']:
            th_ratio += -.1
            resize = True
        elif k == KEY['vsplit_down']:
            th_ratio += +.1
            resize = True

        elif k == KEY['top_next']:
            lbuf.move(+1)
            rbuf.move(+1)
        elif k == KEY['top_prev']:
            lbuf.move(-1)
            rbuf.move(-1)

        elif k == 'KEY_RESIZE':
            resize = True


        if resize:
            H, W = stdscr.getmaxyx()
            lw, rw, th, bh = diff_split(W, H, th_ratio)
            lwin.resize(th, lw)
            rwin.resize(th, rw)
            rwin.mvwin(0, lw+1)
            bwin.resize(bh, W)
            bwin.mvwin(th+1, 0)
            resize = False


        if lbuf.get_packet()[1] != last_lpacket or rbuf.get_packet()[1] != last_rpacket:
            bbuf.set_data(smb_diff(lbuf.get_packet(), rbuf.get_packet()))

if __name__ == '__main__':
    ap = argparse.ArgumentParser(description='compare smb packets')
    ap.add_argument('-c', '--config',
                    help='read alternative config file (default %s)'%DEFAULT_CONFIG)
    ap.add_argument('-k', '--key', metavar='KEYPAIR',
                    default=[], action='append',
                    help='either a path to a kernel log file to extract keys from ('+
                    'needs CONFIG_CIFS_DEBUG_KEYS enabled) or literal session '+
                    'id & key pair given in hex (as SESSID,KEY)')
    ap.add_argument('filea', metavar='CAPFILE1:NO', help='first file/packet number')
    ap.add_argument('fileb', nargs='?', metavar='CAPFILE2:NO',
                    help='second file/packet number (diff mode)')
    args = ap.parse_args()

    if args.config:
        load_config(args.config)
    elif os.path.exists(DEFAULT_CONFIG):
        load_config(DEFAULT_CONFIG)

    wireshark_checks(args)
    load_crypto_keys(args)

    if args.fileb:
        curses.wrapper(diff_view_main, args)
    else:
        curses.wrapper(single_view_main, args)
